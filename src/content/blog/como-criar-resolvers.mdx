---
heroImage: /images/posts/Como-criar-Resolvers.png
category: Angular
description: Nesse artigo voc√™ vai aprender o que s√£o Resolvers no Angular e como criar e usar esse recurso que permite carregar dados durante o roteamento para um componente.
pubDate: '2025-02-02'
draft: false
tags:
  - angular
title: 'Como criar Resolvers no Angular'
authorId: 'henrique-custodia'
---

import Ads from '@ads'

[Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) s√£o recursos muito poderosos que permitem voc√™ carregar dados durante o roteamento para uma p√°gina, ou melhor, para um componente.

Nesse artigo voc√™ vai aprender como utilizar esse recurso fant√°stico!

## O que √© um Resolver?

[Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) s√£o fun√ß√µes que ser√£o rodadas assim que o roteamento para um determinado componente ser iniciado.

Esse recurso pode ser muito √∫til quando voc√™ precisar carregar algum dado antes mesmo do componente vinculado a esse roteamento ser criado.

Alguns cen√°rios de uso seriam:

- Evitar que os elementos da tela renderizem de forma "quebrada", trazendo uma experi√™ncia mais agrad√°vel para o usu√°rio
- Melhorar a sincronia do consumo de dados nos componentes
- Dimininui√ß√£o da complexidade dos componentes, uma vez que todos os dados j√° est√£o carregados antes de renderizar o componente

Um ponto importante sobre os [Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) √© que o componente vinculado ao roteamento
s√≥ ser√° renderizado quando todos os [Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) tiverem suas rotinas finalizadas.

[Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) podem retornar
uma [`Promise`](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise), [`Observable`](https://rxjs.dev/guide/observable) ou um objeto
j√° resolvido que ser√° enviado para o componente.

> Note que se voc√™ retornar uma [`Promise`](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise) ou uma [`Observable`](https://rxjs.dev/guide/observable),
> o Angular aguardar√° a conclus√£o da mesma para ent√£o renderizar o componente.

## Como criar um Resolver

No exemplo abaixo vamos criar um [Resolver](https://angular.dev/api/router/ResolveFn?tab=usage-notes) que recuperar√° um objeto `Task` utilizando seu identificador (`id`) que est√° na rota de navega√ß√£o.

```ts
import { inject } from '@angular/core'
import { ResolveFn } from '@angular/router'
import { TasksService } from '../../services/tasks.service'
import { Task } from '../../interfaces/task'

export const getTaskByIdResolver: ResolveFn<Task> = (route) => {
	// faz a inje√ß√£o do service
	const tasksService = inject(TasksService)

	// recupera o id da rota
	const taskId = route.paramMap.get('id') as string

	// recupera a tarefa pelo id
	return tasksService.getById(taskId) // retorna um `Observable<Task>`
}
```

> Voc√™ pode criar um resolver utilizando o comando [`ng g resolver`](https://angular.dev/cli/generate/resolver)

Note que para criar o [Resolver](https://angular.dev/api/router/ResolveFn?tab=usage-notes) precisamos apenas utilizar uma fun√ß√£o que respeita a assinatura de [ResolverFn](https://angular.dev/api/router/ResolveFn).

## Como registrar um Resolver

Para utilizar o [Resolver](https://angular.dev/api/router/ResolveFn?tab=usage-notes) criado acima, basta registrar a fun√ß√£o na configura√ß√£o de roteamento da aplica√ß√£o (geralmente em `app.routes.ts`).

```ts
import { Route } from '@angular/router'
import { getTaskByIdResolver } from './shared/resolvers/get-task-by-id.resolver/get-task-by-id.resolver'
import { isLoggedInGuard } from './shared/guards/is-logged-in.guard'

export const appRoutes: Route[] = [
	{
		path: 'edit/:id',
		resolve: {
			task: getTaskByIdResolver // resolver para recuperar a tarefa
		},
		loadComponent: () => import('./pages/form/edit/edit.component').then((m) => m.EditComponent)
	}
]
```

√â muito importante notar que a propriedade `task`, dentro do objeto `resolve`, receber√° o valor retornado pelo resolver. Assim, o componente vinculado ao roteamento ter√° acesso ao valor retornado pelo resolver utilizando a propriedade `task`.

<Ads />

## Como consumir um Resolver em um Componente

> Vamos utilizar como exemplo o resolver criado acima como base.

Existem duas formas de recuperar o valor retornado pelo resolver:

### Maneira 1: Utilizando o `ActivatedRoute`

Essa abordagem √© mais antiga e mais verbosa.

```ts
@Component({
	selector: 'app-edit',
	templateUrl: './edit.component.html',
	styleUrls: ['./edit.component.scss']
})
export class EditComponent {
	// recebe o valor retornado pelo resolver
	task: Task | null = null

	// faz a inje√ß√£o do service
	activatedRoute = inject(ActivatedRoute)

	ngOnInit() {
		// recebe o valor retornado pelo resolver
		this.task = this.activatedRoute.snapshot.data['task']
	}
}
```

### Maneira 2: Utilizando o `ActivatedRoute`

Essa abordagem √© nova e suportada em vers√µes mais recentes do Angular.

```ts
@Component({
	selector: 'app-edit',
	templateUrl: './edit.component.html',
	styleUrls: ['./edit.component.scss']
})
export class EditComponent {
	task = input<Task>() // recebe o valor retornado pelo resolver
}
```

Voc√™ precisar√° habilitar a fun√ß√£o [withComponentInputBinding](https://angular.dev/api/router/withComponentInputBinding?tab=api) no seu `app.routes.ts`
para que o valor retornado pelo [Resolver](https://angular.dev/api/router/ResolveFn?tab=usage-notes) seja disponibilizado
via [Input](https://angular.dev/api/core/input#) ao componente vinculado ao roteamento.

```ts
export const appConfig: ApplicationConfig = {
  providers: [
	...
    provideRouter(appRoutes, withComponentInputBinding()),
	...
  ],
};
```

## Quando N√ÉO utilizar resolvers

Existem situa√ß√µes em que ser√° melhor evitar o uso de [Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes).

Alguns exemplos seriam:

- Quando o componente vinculado ao roteamento precisa fazer muitas requisi√ß√µes para ser renderizado, gerando um demora significativa no carregamento do componente e degradando a experi√™ncia do usu√°rio.
- Se os [endpoints](https://pt.stackoverflow.com/questions/86399/qual-a-diferen%C3%A7a-entre-endpoint-e-api) que ser√£o consumidos demoram mais de **500ms** para responder, √© melhor fazer o carregamento dos dados ap√≥s o componentes j√° estiverem renderizados para evitar problemas de usabilidade.

Utilize [Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) somente quando for necess√°rio carregar dados com um tempo de resposta menor que **500ms**.
Essa abordagem garantir√° uma experi√™ncia quase inst√¢ntanea ao usu√°rio ao carregar o componente.

---

[Resolvers](https://angular.dev/api/router/ResolveFn?tab=usage-notes) s√£o recursos muito poderosos que permitem voc√™ carregar dados durante o roteamento para componente.

Essa abordagem traz benef√≠cios e tamb√©m malef√≠cios para a experi√™ncia de uso da aplica√ß√£o. Por isso, utilize de forma conciente, ok?

Obrigado por ler at√© aqui e at√© mais! üòé
